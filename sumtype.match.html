<!DOCTYPE html>
<html lang="en">
<head>
        <title>match (sumtype.match)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>match</h1><div class="breadcrumbs"><a class="breadcrumb" href="sumtype.html">sumtype</a> </div><div><div class="documentation-comment synopsis"><div><p>Calls a type-appropriate function with the value held in a <a class="xref" href="sumtype.SumType.html">SumType</a>.</p><p>For each possible type the <a class="xref" href="sumtype.SumType.html">SumType</a> can hold, the given handlers are
checked, in order, to see whether they accept a single argument of that type.
The first one that does is chosen as the match for that type. (Note that the
first match may not always be the most exact match.
See <a class="" href="sumtype.match.html#avoiding-unintentional-matches">&quot;Avoiding unintentional matches&quot;</a> for
one common pitfall.)</p><p>Every type must have a matching handler, and every handler must match at
least one type. This is enforced at compile time.</p><p>Handlers may be functions, delegates, or objects with <tt class="inline-code">opCall</tt> overloads. If
a function with more than one overload is given as a handler, all of the
overloads are considered as potential matches.</p><p>Templated handlers are also accepted, and will match any type for which they
can be <a href="https://dlang.org/glossary.html#ifti">implicitly instantiated</a>. See
<a class="xref" href="sumtype.html#introspection-based-matching">&quot;Introspection-based matching&quot;</a> for an
example of templated handler usage.</p><p>If multiple <a class="xref" href="sumtype.SumType.html">SumType</a>s are passed to <tt class="inline-code">match</tt>, their values are passed to the
handlers as separate arguments, and matching is done for each possible
combination of value types. See <a class="" href="sumtype.match.html#multiple-dispatch">&quot;Multiple dispatch&quot;</a> for
an example.</p></div></div></div><div class="annotated-prototype"><div class="function-prototype"><div class="parent-prototype"><span class="builtin-type">template</span> <span class="name">match</span><span class="template-params">(handlers...)</span></div><div><div class="attributes">ref </div><div class="return-type"><a class="lang-feature" href="http://dpldocs.info/auto-ref-function-return-prototype">auto ref</a> </div><div class="function-name">match</div><div class="template-parameters" data-count="1">(<div class="parameters-list toplevel"><div class="template-parameter-item parameter-item">	<span><span class="name" data-ident="SumTypes">SumTypes</span>...</span></div></div>)</div><div class="runtime-parameters" data-count="1"><div class="parameters-list toplevel"><span class="paren">(</span><div class="runtime-parameter-item parameter-item"><span class="parameter-type-holder"><span class="parameter-type"><span class="storage-class">auto</span> <span class="storage-class">ref</span> <span class="name" data-ident="SumTypes">SumTypes</span></span></span> <span class="parameter-name name" data-ident="args"><a href="#param-args">args</a></span></div><span class="paren">)</span></div></div><div class="template-constraint"> <a class="lang-feature" href="http://dpldocs.info/template-constraints">if</a> (<div class="template-constraint-expression"><div class="andand-left"><span class="name" data-ident="allSatisfy">allSatisfy</span>!(<a class="name" data-ident="isSumType" href="sumtype.isSumType.html" title="sumtype.isSumType">isSumType</a>, <span class="name" data-ident="SumTypes">SumTypes</span>) &amp;&amp; </div><div class="andand-right"><span class="name" data-ident="args">args.length</span> &gt; 0</div></div>)</div><div class="function-contracts"></div></div></div></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="sumtype.match.match.html">match</a><div class="simplified-prototype" style="max-width: 33ch;"><span class="lang-feature">auto ref</span>  <span class="name">match</span>(SumTypes args)</div></dt><dd><div><p>The actual <tt class="inline-code">match</tt> function.</p></div></dd></dl><div><h2 id="returns">Return Value</h2><div><div class="documentation-comment returns-description"><div><p>The value returned from the handler that matches the currently-held type.</p></div></div></div><h2 id="examples"><a class="header-anchor" href="#examples">Examples</a></h2><div class="documentation-comment"><div></div></div><div class="unittest-example-holder"><div class="documentation-comment"><h3 class="user-header" id="avoiding-unintentional-matches">Avoiding unintentional matches</h3><p>Sometimes, implicit conversions may cause a handler to match more types than
intended. The example below shows two solutions to this problem.</p></div><pre class="d_code highlighted"><span class="kwrd">alias</span> <span class="hid">Number</span> = <span class="hid">SumType</span>!(<span class="type">double</span>, <span class="type">int</span>);

<span class="hid">Number</span> <span class="hid">x</span>;

<span class="com">// Problem: because int implicitly converts to double, the double</span>
<span class="com">// handler is used for both types, and the int handler never matches.</span>
<span class="kwrd">assert</span>(!<span class="kwrd">__traits</span>(<span class="hid">compiles</span>,
    <span class="hid">x</span>.<span class="hid">match</span>!(
        (<span class="type">double</span> <span class="hid">d</span>) =&gt; <span class="str">&quot;got double&quot;</span>,
        (<span class="type">int</span> <span class="hid">n</span>) =&gt; <span class="str">&quot;got int&quot;</span>
    )
));

<span class="com">// Solution 1: put the handler for the &quot;more specialized&quot; type (in this</span>
<span class="com">// case, int) before the handler for the type it converts to.</span>
<span class="kwrd">assert</span>(<span class="kwrd">__traits</span>(<span class="hid">compiles</span>,
    <span class="hid">x</span>.<span class="hid">match</span>!(
        (<span class="type">int</span> <span class="hid">n</span>) =&gt; <span class="str">&quot;got int&quot;</span>,
        (<span class="type">double</span> <span class="hid">d</span>) =&gt; <span class="str">&quot;got double&quot;</span>
    )
));

<span class="com">// Solution 2: use a template that only accepts the exact type it's</span>
<span class="com">// supposed to match, instead of any type that implicitly converts to it.</span>
<span class="kwrd">alias</span> <span class="hid">exactly</span>(<span class="hid">T</span>, <span class="kwrd">alias</span> <span class="hid">fun</span>) = <span class="kwrd">function</span> (<span class="hid">arg</span>) {
    <span class="kwrd">static</span> <span class="kwrd">assert</span>(<span class="kwrd">is</span>(<span class="kwrd">typeof</span>(<span class="hid">arg</span>) == <span class="hid">T</span>));
    <span class="kwrd">return</span> <span class="hid">fun</span>(<span class="hid">arg</span>);
};

<span class="com">// Now, even if we put the double handler first, it will only be used for</span>
<span class="com">// doubles, not ints.</span>
<span class="kwrd">assert</span>(<span class="kwrd">__traits</span>(<span class="hid">compiles</span>,
    <span class="hid">x</span>.<span class="hid">match</span>!(
        <span class="hid">exactly</span>!(<span class="type">double</span>, <span class="hid">d</span> =&gt; <span class="str">&quot;got double&quot;</span>),
        <span class="hid">exactly</span>!(<span class="type">int</span>, <span class="hid">n</span> =&gt; <span class="str">&quot;got int&quot;</span>)
    )
));</pre></div><div class="unittest-example-holder"><div class="documentation-comment"><h3 class="user-header" id="multiple-dispatch">Multiple dispatch</h3><p>Pattern matching can be performed on multiple <tt class="inline-code">SumType</tt>s at once by passing
handlers with multiple arguments. This usually leads to more concise code
than using nested calls to <tt class="inline-code">match</tt>, as show below.</p></div><pre class="d_code highlighted"><span class="kwrd">struct</span> <span class="hid">Point2D</span> { <span class="type">double</span> <span class="hid">x</span>, <span class="hid">y</span>; }
<span class="kwrd">struct</span> <span class="hid">Point3D</span> { <span class="type">double</span> <span class="hid">x</span>, <span class="hid">y</span>, <span class="hid">z</span>; }

<span class="kwrd">alias</span> <span class="hid">Point</span> = <span class="hid">SumType</span>!(<span class="hid">Point2D</span>, <span class="hid">Point3D</span>);

<span class="kwrd">version</span> (<span class="hid">none</span>) {
    <span class="com">// This function works, but the code is ugly and repetitive.</span>
    <span class="com">// It uses three separate calls to match!</span>
    @<span class="hid">safe</span> <span class="kwrd">pure</span> <span class="kwrd">nothrow</span> @<span class="hid">nogc</span>
    <span class="type">bool</span> <span class="hid">sameDimensions</span>(<span class="hid">Point</span> <span class="hid">p1</span>, <span class="hid">Point</span> <span class="hid">p2</span>)
    {
        <span class="kwrd">return</span> <span class="hid">p1</span>.<span class="hid">match</span>!(
            (<span class="hid">Point2D</span> <span class="hid">_</span>) =&gt; <span class="hid">p2</span>.<span class="hid">match</span>!(
                (<span class="hid">Point2D</span> <span class="hid">_</span>) =&gt; <span class="kwrd">true</span>,
                <span class="hid">_</span> =&gt; <span class="kwrd">false</span>
            ),
            (<span class="hid">Point3D</span> <span class="hid">_</span>) =&gt; <span class="hid">p2</span>.<span class="hid">match</span>!(
                (<span class="hid">Point3D</span> <span class="hid">_</span>) =&gt; <span class="kwrd">true</span>,
                <span class="hid">_</span> =&gt; <span class="kwrd">false</span>
            )
        );
    }
}

<span class="com">// This version is much nicer.</span>
@<span class="hid">safe</span> <span class="kwrd">pure</span> <span class="kwrd">nothrow</span> @<span class="hid">nogc</span>
<span class="type">bool</span> <span class="hid">sameDimensions</span>(<span class="hid">Point</span> <span class="hid">p1</span>, <span class="hid">Point</span> <span class="hid">p2</span>)
{
    <span class="kwrd">alias</span> <span class="hid">doMatch</span> = <span class="hid">match</span>!(
        (<span class="hid">Point2D</span> <span class="hid">_1</span>, <span class="hid">Point2D</span> <span class="hid">_2</span>) =&gt; <span class="kwrd">true</span>,
        (<span class="hid">Point3D</span> <span class="hid">_1</span>, <span class="hid">Point3D</span> <span class="hid">_2</span>) =&gt; <span class="kwrd">true</span>,
        (<span class="hid">_1</span>, <span class="hid">_2</span>) =&gt; <span class="kwrd">false</span>
    );

    <span class="kwrd">return</span> <span class="hid">doMatch</span>(<span class="hid">p1</span>, <span class="hid">p2</span>);
}

<span class="hid">Point</span> <span class="hid">a</span> = <span class="hid">Point2D</span>(<span class="num">1</span>, <span class="num">2</span>);
<span class="hid">Point</span> <span class="hid">b</span> = <span class="hid">Point2D</span>(<span class="num">3</span>, <span class="num">4</span>);
<span class="hid">Point</span> <span class="hid">c</span> = <span class="hid">Point3D</span>(<span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>);
<span class="hid">Point</span> <span class="hid">d</span> = <span class="hid">Point3D</span>(<span class="num">8</span>, <span class="num">9</span>, <span class="num">0</span>);

<span class="kwrd">assert</span>( <span class="hid">sameDimensions</span>(<span class="hid">a</span>, <span class="hid">b</span>));
<span class="kwrd">assert</span>( <span class="hid">sameDimensions</span>(<span class="hid">c</span>, <span class="hid">d</span>));
<span class="kwrd">assert</span>(!<span class="hid">sameDimensions</span>(<span class="hid">a</span>, <span class="hid">c</span>));
<span class="kwrd">assert</span>(!<span class="hid">sameDimensions</span>(<span class="hid">d</span>, <span class="hid">b</span>));</pre></div><h2 id="see-also">See Also</h2><div class="documentation-comment see-also-section"><div><p><tt class="inline-code">std.variant.visit</tt></p></div></div><h2 id="meta">Meta</h2><div class="documentation-comment source-section other-section"><h3 id="source">Source</h3><div><p><a href="source/sumtype.d.html#L1557">See Implementation</a><br /></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="sumtype.html">sumtype</a> 
		<span class="type-separator">classes</span><ul><li><a class="class" href="sumtype.MatchException.html">MatchException</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="sumtype.SumType.html">SumType</a></li><li><a class="struct" href="sumtype.This.html">This</a></li></ul><span class="type-separator">templates</span><ul><li><a class="template" href="sumtype.canMatch.html">canMatch</a></li><li><a class="template" href="sumtype.isSumType.html">isSumType</a></li><li><a class="template current" href="sumtype.match.html">match</a></li><li><a class="template" href="sumtype.tryMatch.html">tryMatch</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>